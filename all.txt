You will be provided with a markdown text (under the "---" separator) containing the contents of a codebase. Each code snippet will be enclosed in code fences, along with the corresponding file name. Your task is to analyze the codebase and gain a comprehensive understanding of its structure, functionality, and key features.

Please follow these steps:

1. Read through the entire codebase carefully, paying attention to the file names and the code within each code fence.
2. Identify the main components, modules, or classes of the codebase and their responsibilities. Summarize the purpose and functionality of each significant component.
3. Analyze the relationships and dependencies between different parts of the codebase. Identify any important interactions, data flow, or control flow between the components.
4. Extract the most important features and functionalities implemented in the codebase. Highlight any critical algorithms, data structures, or design patterns used.
5. Consider the overall architecture and design of the codebase. Identify any architectural patterns or principles followed, such as MVC, MVVM, or microservices.
6. Evaluate the code quality, readability, and maintainability. Note any areas that could be improved or any potential issues or vulnerabilities.
7. Provide a summary of your analysis, including the key insights, strengths, and weaknesses of the codebase. Offer suggestions for improvements or optimizations, if applicable.
8. Based on your understanding of the codebase, provide guidance on how AI agents can effectively operate across the entire codebase. Identify the entry points, important functions, or APIs that the agents should focus on for interaction and manipulation.
9. Discuss any specific considerations or challenges that AI agents may face when working with this codebase, such as dependencies, external libraries, or platform-specific requirements.
10. Conclude your analysis by providing a high-level overview of the codebase's functionality, architecture, and potential use cases. Highlight any notable features or aspects that make this codebase unique or valuable.

Your analysis should be thorough, insightful, and aimed at enabling AI agents to effectively understand and operate within the given codebase. Provide clear explanations and examples to support your findings and recommendations.

---



`exec/git.go`

```go
package exec

import (
	"context"
	"fmt"
	"os/exec"
	"strings"
)

// GitLog executes git log command and prints last 20 commit hashes with messages in DESC order
func GitLog(ctx context.Context) error {
	// Execute git log command with formatting to get hash and message
	// --oneline gives us abbreviated commit hash and subject (first line of commit message)
	// -20 limits to last 20 commits
	// Commits are shown in DESC order by default (newest first)
	cmd := exec.CommandContext(ctx, "git", "log", "--oneline", "-20")

	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to execute git log: %w", err)
	}

	// Convert output to string and split by lines
	lines := strings.Split(strings.TrimSpace(string(output)), "\n")

	// Print each commit line
	for _, line := range lines {
		if line != "" {
			fmt.Println(line)
		}
	}

	return nil
}

// GetSquashableCommits returns commits that haven't been pushed to the remote repository yet
func GetSquashableCommits(ctx context.Context) ([]string, error) {
	// First, try to get the upstream branch
	upstreamCmd := exec.CommandContext(ctx, "git", "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}")
	upstreamOutput, err := upstreamCmd.Output()

	var baseCommit string
	if err != nil {
		// If no upstream, try to get the default remote branch
		defaultBranches := []string{"origin/main", "origin/master", "origin/develop"}
		found := false

		for _, branch := range defaultBranches {
			checkCmd := exec.CommandContext(ctx, "git", "rev-parse", "--verify", branch)
			if checkCmd.Run() == nil {
				baseCommit = branch
				found = true
				break
			}
		}

		// If still no remote branch found, get all commits except the first one
		if !found {
			// Modified to get commit hash, author, date, and message
			cmd := exec.CommandContext(ctx, "git", "log", "--pretty=format:%h|%an|%ar|%s")
			output, err := cmd.Output()
			if err != nil {
				return nil, fmt.Errorf("failed to execute git log: %w", err)
			}

			// Convert output to string and split by lines
			lines := strings.Split(strings.TrimSpace(string(output)), "\n")

			// Filter out empty lines
			var commits []string
			for _, line := range lines {
				if line != "" {
					commits = append(commits, line)
				}
			}

			// Return all commits except the first one (oldest)
			if len(commits) > 1 {
				return commits[:len(commits)-1], nil
			}

			// If there's only one or no commits, return empty slice
			return []string{}, nil
		}
	} else {
		// Use the upstream branch
		baseCommit = strings.TrimSpace(string(upstreamOutput))
	}

	// Get commits that are local (not pushed yet) with hash, author, date, and message
	cmd := exec.CommandContext(ctx, "git", "log", "--pretty=format:%h|%an|%ar|%s", fmt.Sprintf("%s..HEAD", baseCommit))

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to execute git log: %w", err)
	}

	// Convert output to string and split by lines
	lines := strings.Split(strings.TrimSpace(string(output)), "\n")

	// Filter out empty lines
	var commits []string
	for _, line := range lines {
		if line != "" {
			commits = append(commits, line)
		}
	}

	return commits, nil
}
```

`handlers/handler.go`

```go
package handlers

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/andrejsstepanovs/git-squash/exec"
	"github.com/eiannone/keyboard"
	"github.com/fatih/color"
)

// MainHandler retrieves the current user absolute directory and prints it
// Then calls GitLog to show last 20 commits
func MainHandler(ctx context.Context) error {
	dir, err := filepath.Abs(".")
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	// Add color to directory output
	cyan := color.New(color.FgCyan).SprintFunc()
	fmt.Printf("Current directory: %s\n", cyan(dir))

	// Add color to section header
	header := color.New(color.FgHiBlue, color.Bold).SprintFunc()
	fmt.Printf("\n%s\n", header("Last 20 commits:"))
	err = exec.GitLog(ctx)
	if err != nil {
		return fmt.Errorf("failed to get git log: %w", err)
	}

	// Get squashable commits
	fmt.Printf("\n%s\n", header("Squashable commits:"))
	commits, err := exec.GetSquashableCommits(ctx)
	if err != nil {
		return fmt.Errorf("failed to get squashable commits: %w", err)
	}

	if len(commits) == 0 {
		yellow := color.New(color.FgYellow).SprintFunc()
		fmt.Println(yellow("No squashable commits found."))
		return nil
	}

	// Interactive commit selection
	selectedCommit, err := selectCommit(ctx, commits)
	if err != nil {
		return fmt.Errorf("failed to select commit: %w", err)
	}

	green := color.New(color.FgGreen).SprintFunc()
	fmt.Printf("\n%s %s\n", green("Selected commit:"), selectedCommit)

	return nil
}

// formatCommitLine formats a commit line with hash, author, time, and message
func formatCommitLine(commitLine string) string {
	parts := strings.SplitN(commitLine, "|", 4)
	if len(parts) < 4 {
		return commitLine // Return as is if not in expected format
	}

	hash := parts[0]
	author := parts[1]
	time := parts[2]
	message := parts[3]

	// Trim message to 50 characters and ensure it's a single line
	message = strings.TrimSpace(message)
	if len(message) > 50 {
		message = message[:50] + "..."
	}
	// Replace newlines with spaces
	message = strings.ReplaceAll(message, "\n", " ")
	message = strings.ReplaceAll(message, "\r", " ")

	// Format the commit line with colors
	hashColor := color.New(color.FgYellow).SprintFunc()
	authorColor := color.New(color.FgGreen).SprintFunc()
	timeColor := color.New(color.FgCyan).SprintFunc()
	messageColor := color.New(color.FgWhite).SprintFunc()

	return fmt.Sprintf("%s %s %s %s", 
		hashColor(hash), 
		authorColor(author), 
		timeColor(time), 
		messageColor(message))
}

// selectCommit allows user to interactively select a commit using arrow keys
func selectCommit(ctx context.Context, commits []string) (string, error) {
	if len(commits) == 0 {
		return "", fmt.Errorf("no commits to select")
	}

	// Initialize keyboard
	if err := keyboard.Open(); err != nil {
		return "", fmt.Errorf("failed to open keyboard: %w", err)
	}
	defer keyboard.Close()

	selectedIndex := 0

	// Print commits with selection indicator
	printCommitsWithSelection(commits, selectedIndex)

	// Create a channel for keyboard input
	keyboardChan := make(chan keyboard.KeyEvent)
	errorChan := make(chan error)

	go func() {
		defer close(keyboardChan)
		for {
			char, key, err := keyboard.GetKey()
			if err != nil {
				select {
				case errorChan <- err:
				case <-ctx.Done():
				}
				return
			}

			event := keyboard.KeyEvent{Rune: char, Key: key}
			select {
			case keyboardChan <- event:
			case <-ctx.Done():
				return
			}
		}
	}()

	for {
		select {
		case <-ctx.Done():
			clearLines(len(commits) + 2) // +2 for instruction line and header
			fmt.Println("\n\nOperation cancelled.")
			return "", fmt.Errorf("operation cancelled: %w", ctx.Err())
		case err := <-errorChan:
			clearLines(len(commits) + 2) // +2 for instruction line and header
			return "", fmt.Errorf("keyboard error: %w", err)
		case event := <-keyboardChan:
			// Clear previous output
			clearLines(len(commits) + 2) // +2 for instruction line and header

			switch event.Key {
			case keyboard.KeyArrowUp:
				if selectedIndex > 0 {
					selectedIndex--
				}
			case keyboard.KeyArrowDown:
				if selectedIndex < len(commits)-1 {
					selectedIndex++
				}
			case keyboard.KeyEnter:
				// Extract just the hash from the selected commit
				selectedCommit := commits[selectedIndex]
				parts := strings.SplitN(selectedCommit, "|", 4)
				if len(parts) >= 1 {
					return parts[0], nil // Return just the hash
				}
				return selectedCommit, nil
			case keyboard.KeyEsc:
				fmt.Println("\nSelection cancelled.")
				return "", fmt.Errorf("selection cancelled")
			default:
				// Handle Ctrl+C (KeyCtrlC) and Ctrl+D (KeyCtrlD)
				if event.Key == keyboard.KeyCtrlC || event.Key == keyboard.KeyCtrlD {
					clearLines(len(commits) + 2) // +2 for instruction line and header
					fmt.Println("\n\nSelection cancelled.")
					return "", fmt.Errorf("selection cancelled")
				}
				// Also handle raw rune for Ctrl+C (char code 3) just in case
				if event.Rune == 3 || event.Rune == 4 { // 3=Ctrl+C, 4=Ctrl+D
					clearLines(len(commits) + 2) // +2 for instruction line and header
					fmt.Println("\n\nSelection cancelled.")
					return "", fmt.Errorf("selection cancelled")
				}
			}

			// Print commits with updated selection
			printCommitsWithSelection(commits, selectedIndex)
		}
	}
}

// printCommitsWithSelection prints commits with a selection indicator
func printCommitsWithSelection(commits []string, selectedIndex int) {
	instruction := color.New(color.FgHiMagenta).SprintFunc()
	fmt.Printf("%s\n", instruction("Select a commit (use arrow keys to navigate, Enter to select, Esc to cancel):"))
	
	// Add column headers
	header := color.New(color.FgHiWhite, color.Bold).SprintFunc()
	fmt.Printf("%s\n", header("HASH   AUTHOR        TIME                 MESSAGE"))
	
	for i, commit := range commits {
		formattedCommit := formatCommitLine(commit)
		if i == selectedIndex {
			// Highlight selected commit
			selected := color.New(color.FgHiWhite, color.BgBlue).SprintFunc()
			fmt.Printf("> %s\n", selected(formattedCommit))
		} else {
			// Normal commit color
			fmt.Printf("  %s\n", formattedCommit)
		}
	}
}

// clearLines clears the specified number of lines from the terminal
func clearLines(n int) {
	for i := 0; i < n; i++ {
		fmt.Print("\033[1A\033[K")
	}
}
```

`main.go`

```go
package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"github.com/andrejsstepanovs/git-squash/handlers"
	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "git-squash",
	Short: "A CLI tool to squash git commits",
	Long:  `git-squash is a CLI tool that helps you squash multiple git commits into a single commit.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		return handlers.MainHandler(cmd.Context())
	},
}

func main() {
	// Create context with cancel and signal handling
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Set up signal handling
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		cancel()
	}()

	err := rootCmd.ExecuteContext(ctx)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
```

